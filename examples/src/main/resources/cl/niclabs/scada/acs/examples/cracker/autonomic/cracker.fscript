function contains-name(slaveName, slaves) {
    for slave : $slaves {
        if ($slaveName == name($slave)) {
            return true();
        }
    }
    return false();
}

function get-next-available-name(slaves) {
    if (not(contains-name("Slave0", $slaves))) {
        return "Slave0";
    }
    if (not(contains-name("Slave1", $slaves))) {
        return "Slave1";
    }
    if (not(contains-name("Slave2", $slaves))) {
        return "Slave2";
    }
    if (not(contains-name("Slave3", $slaves))) {
        return "Slave3";
    }
    if (not(contains-name("Slave4", $slaves))) {
        return "Slave4";
    }
    if (not(contains-name("Slave5", $slaves))) {
        return "Slave5";
    }
    if (not(contains-name("Slave6", $slaves))) {
        return "Slave6";
    }
    if (not(contains-name("Slave7", $slaves))) {
        return "Slave7";
    }
}

function get-last-used-name(slaves) {
    if (contains-name("Slave7", $slaves)) {
        return "Slave7";
    }
    if (contains-name("Slave6", $slaves)) {
        return "Slave6";
    }
    if (contains-name("Slave5", $slaves)) {
        return "Slave5";
    }
    if (contains-name("Slave4", $slaves)) {
        return "Slave4";
    }
    if (contains-name("Slave3", $slaves)) {
        return "Slave3";
    }
    if (contains-name("Slave2", $slaves)) {
        return "Slave2";
    }
    if (contains-name("Slave1", $slaves)) {
        return "Slave1";
    }
    if (contains-name("Slave0", $slaves)) {
        return "Slave0";
    }
}

function slaves-number(solver) {
    return size($solver/child::*[starts-with(name(.), "Slave")]);
}

action stopped-lifecycle-add-slaves(solver, number) {

    if (state($solver) != "STOPPED") {
        return false();
    }

    if ($number <= 0) {
        return true();
    }

    node = $solver/deployment-gcmnode::*;
    slave = gcm-new("cl.niclabs.scada.acs.examples.cracker.solver.component.Slave", $node);

    oldSlaves = $solver/child::*[starts-with(name(.), "Slave")];
    set-name($slave, get-next-available-name($oldSlaves));

    add($solver, $slave);
    bind($solver/child::Master/interface::multicast-slave-itf, $slave/interface::slave-itf);
    set-value($solver/child::Master/attribute::partitionsNumber, slaves-number($solver));

    return stopped-lifecycle-add-slaves($solver, $number - 1);
}

action add-slaves(solver, number) {

    solverState = state($solver);
    if ($solverState == "STARTED") {
        stop($solver);
    }

    r = stopped-lifecycle-add-slaves($solver, $number);

    if ($solverState == "STARTED") {
        start($solver);
    }

    return $r;
}

action add-slave(solver) {
    add-slaves($solver, 1);
}

action stopped-lifecycle-remove-slaves(solver, number) {

    if (state($solver) != "STOPPED") {
        return false();
    }

    if ($number <= 0) {
        return true();
    }

    currentSlaves = $solver/child::*[starts-with(name(.), "Slave")];
    toRemove = $solver/child::*[name(.) == get-last-used-name($currentSlaves)];

    unbind-unit($solver/child::Master/interface::multicast-slave-itf, $toRemove/interface::slave-itf);
    remove($solver, $toRemove);
    set-value($solver/child::Master/attribute::partitionsNumber, size($currentSlaves) - 1);

    return stopped-lifecycle-remove-slaves($solver, $number - 1);
}

action remove-slaves(solver, number) {

    solverState = state($solver);
    if ($solverState == "STARTED") {
        stop($solver);
    }

    r = stopped-lifecycle-remove-slaves($solver, $number);

    if ($solverState == "STARTED") {
        start($solver);
    }

    return $r;
}

action remove-slave(solver) {
    remove-slaves($solver, 1);
}


-- TEST ---------------------------

action enable-balancer(cracker) {
    set-state($cracker/metric::dummyDistributionPoint, "DISABLED");
    set-state($cracker/metric::distributionPoint, "ENABLED");
    set-state($cracker/rule::balanceState, "ENABLED");
    set-state($cracker/plan::balanceUpdater, "ENABLED");
}

action enable-adder(cracker) {
    set-state($cracker/rule::maxRespTime, "DISABLED");
    set-state($cracker/plan::slavesRemover, "DISABLED");

    set-state($cracker/rule::minRespTime, "ENABLED");
    set-state($cracker/plan::slavesAdder, "ENABLED");
}

action enable-remover(cracker) {
    set-state($cracker/rule::minRespTime, "DISABLED");
    set-state($cracker/plan::slavesAdder, "DISABLED");

    set-state($cracker/rule::maxRespTime, "ENABLED");
    set-state($cracker/plan::slavesRemover, "ENABLED");
}

action phase1(cracker) {
    add-slaves($this/child::Solver2, 2);
}

action phase2(cracker) {
    add-slaves($this/child::Solver2, 3);
    add-slaves($this/child::Solver1, 2);
}

action phase3(cracker) {
    remove-slaves($this/child::Solver2, 5);
    remove-slaves($this/child::Solver1, 2);
    add-slaves($this/child::Solver0, 5);
}